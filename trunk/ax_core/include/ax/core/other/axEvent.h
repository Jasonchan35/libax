#ifndef __axEvent_h__
#define __axEvent_h__
#include "../data_structure/axTinyList.h" 

/* !!!! 

This file generated by tools/axEvent_generator.html ( java script ) 

*/



 template<            class RET, class P0=void, class P1=void, class P2=void, class P3=void > class axIFunctor;
 template< class OBJ, class RET, class P0=void, class P1=void, class P2=void, class P3=void > class axFunctor;
 template<            class RET, class P0=void, class P1=void, class P2=void, class P3=void > class axDelegate;
 template<            class RET, class P0=void, class P1=void, class P2=void, class P3=void > class axEvent;


//==== 4 Param(s) ======================================

	template< class RET, class P0, class P1, class P2, class P3 >
	class axIFunctor {
	public:
		virtual ~axIFunctor() {}
		virtual	RET call( P0 p0, P1 p1, P2 p2, P3 p3 ) = 0;
	};
	
//---- Functor 4-----------------------------------

	// Member function
	template< class OBJ, class RET, class P0, class P1, class P2, class P3 >
	class axFunctor : public axIFunctor< RET, P0, P1, P2, P3 > {
	public:
		typedef RET (OBJ::*Func)( P0 p0, P1 p1, P2 p2, P3 p3 );
		axFunctor( OBJ* obj=nullptr, Func func=nullptr ) : obj_(obj), func_(func) {}
	private:
		OBJ* 	obj_;
		Func	func_;
		virtual RET call( P0 p0, P1 p1, P2 p2, P3 p3 ) { return (obj_->*func_)(p0, p1, p2, p3); }
	};
	
	
	// static function
	template< class RET, class P0, class P1, class P2, class P3 >
	class axFunctor< void, RET, P0, P1, P2, P3 > : public axIFunctor< RET, P0, P1, P2, P3 > {
	public:
		typedef RET (*Func)( P0 p0, P1 p1, P2 p2, P3 p3 );
		axFunctor( Func func=nullptr ) : func_(func) {}
	private:
		Func	func_;
		virtual RET call( P0 p0, P1 p1, P2 p2, P3 p3 ) { return (*func_)(p0, p1, p2, p3); }
	};

//---- Delegate 4-----------------------------------

	template< class RET, class P0, class P1, class P2, class P3 >
	class axDelegate : public axTinyListNode< axDelegate< RET, P0, P1, P2, P3 >, false > {
	typedef	axEvent		< RET, P0, P1, P2, P3 > EV;
	typedef	axDelegate	< RET, P0, P1, P2, P3 > D;

	typedef	axTinyListNode< D, false > ListNode;
	public:
		RET	operator()	(P0 p0, P1 p1, P2 p2, P3 p3)	{ return _call(p0, p1, p2, p3); }

		axDelegate() {} 

		template< class OBJ >
		axDelegate ( OBJ* obj, RET (OBJ::*method)(P0 p0, P1 p1, P2 p2, P3 p3) ) {
			set(obj,method);
		}

		axDelegate ( RET (*func)(P0 p0, P1 p1, P2 p2, P3 p3) ) {
			set(func);
		}

		template< class OBJ >
		void set ( OBJ* obj, RET (OBJ::*method)(P0 p0, P1 p1, P2 p2, P3 p3) ) {
			functor = new(buf) axFunctor< OBJ, RET, P0, P1, P2, P3>( obj, method );
		}

		void set ( RET (*func)(P0 p0, P1 p1, P2 p2, P3 p3) ) {
			functor = new(buf) axFunctor< void, RET, P0, P1, P2, P3>( func );
		}

		template< class OBJ >
		void connect ( EV & ev, OBJ* obj, RET (OBJ::*method)(P0 p0, P1 p1, P2 p2, P3 p3) ) {
			disconnect(); set( obj, method ); ev.addDelegate( *this );
		}

		void connect		( EV & ev, RET (*func)(P0 p0, P1 p1, P2 p2, P3 p3) ) {
			disconnect	(); set( func ); ev.addDelegate( *this );
		}

		void disconnect	() { ListNode::removeFromList(); }

		EV*	 event ()  { return (EV*) ListNode::list();   }

		axStatus onTake( axDelegate & src ) { 
			disconnect(); 
			if( src.event() ) src.event()->addDelegate( *this ); 
			return 0;
		}

		RET	_call (P0 p0, P1 p1, P2 p2, P3 p3) { return functor ? functor->call(p0, p1, p2, p3) : RET(); }

	private:
		axPtr< axIFunctor< RET, P0, P1, P2, P3 > >	functor;
		char buf[ sizeof( axFunctor< axUnused, RET, P0, P1, P2, P3> ) ];
	};

//----- Event 4----------------------------------

	template< class RET, class P0, class P1, class P2, class P3 >
	class axEvent : private axTinyList< axDelegate< RET, P0, P1, P2, P3 > > {
		typedef axDelegate< RET, P0, P1, P2, P3 > D;
		typedef axTinyList< D > B;
	public:
		void	operator()	(P0 p0, P1 p1, P2 p2, P3 p3)	{ _call(p0, p1, p2, p3); }

		bool	hasDelegate	()			{ return B::head() != NULL; }
		void	addDelegate	( D & d )	{ B::insert(&d); }

		operator	bool()				{ return hasDelegate(); }
		void operator	+=( D & d )		{ addDelegate(d); }

		void	_call (P0 p0, P1 p1, P2 p2, P3 p3) {
			D* p=B::head();
			D* next;
			for( ; p; p=next ) { 
				next = p->next(); // *p might be delete after call
				p->_call(p0, p1, p2, p3);
			} 
		}
	};



//==== 3 Param(s) ======================================

	template< class RET, class P0, class P1, class P2 >
	class axIFunctor< RET, P0, P1, P2, void > {
	public:
		virtual ~axIFunctor() {}
		virtual	RET call( P0 p0, P1 p1, P2 p2 ) = 0;
	};
	
//---- Functor 3-----------------------------------

	// Member function
	template< class OBJ, class RET, class P0, class P1, class P2 >
	class axFunctor< OBJ, RET, P0, P1, P2, void > : public axIFunctor< RET, P0, P1, P2, void > {
	public:
		typedef RET (OBJ::*Func)( P0 p0, P1 p1, P2 p2 );
		axFunctor( OBJ* obj=nullptr, Func func=nullptr ) : obj_(obj), func_(func) {}
	private:
		OBJ* 	obj_;
		Func	func_;
		virtual RET call( P0 p0, P1 p1, P2 p2 ) { return (obj_->*func_)(p0, p1, p2); }
	};
	
	
	// static function
	template< class RET, class P0, class P1, class P2 >
	class axFunctor< void, RET, P0, P1, P2, void > : public axIFunctor< RET, P0, P1, P2, void > {
	public:
		typedef RET (*Func)( P0 p0, P1 p1, P2 p2 );
		axFunctor( Func func=nullptr ) : func_(func) {}
	private:
		Func	func_;
		virtual RET call( P0 p0, P1 p1, P2 p2 ) { return (*func_)(p0, p1, p2); }
	};

//---- Delegate 3-----------------------------------

	template< class RET, class P0, class P1, class P2 >
	class axDelegate< RET, P0, P1, P2, void > : public axTinyListNode< axDelegate< RET, P0, P1, P2, void >, false > {
	typedef	axEvent		< RET, P0, P1, P2, void > EV;
	typedef	axDelegate	< RET, P0, P1, P2, void > D;

	typedef	axTinyListNode< D, false > ListNode;
	public:
		RET	operator()	(P0 p0, P1 p1, P2 p2)	{ return _call(p0, p1, p2); }

		axDelegate() {} 

		template< class OBJ >
		axDelegate ( OBJ* obj, RET (OBJ::*method)(P0 p0, P1 p1, P2 p2) ) {
			set(obj,method);
		}

		axDelegate ( RET (*func)(P0 p0, P1 p1, P2 p2) ) {
			set(func);
		}

		template< class OBJ >
		void set ( OBJ* obj, RET (OBJ::*method)(P0 p0, P1 p1, P2 p2) ) {
			functor = new(buf) axFunctor< OBJ, RET, P0, P1, P2, void>( obj, method );
		}

		void set ( RET (*func)(P0 p0, P1 p1, P2 p2) ) {
			functor = new(buf) axFunctor< void, RET, P0, P1, P2, void>( func );
		}

		template< class OBJ >
		void connect ( EV & ev, OBJ* obj, RET (OBJ::*method)(P0 p0, P1 p1, P2 p2) ) {
			disconnect(); set( obj, method ); ev.addDelegate( *this );
		}

		void connect		( EV & ev, RET (*func)(P0 p0, P1 p1, P2 p2) ) {
			disconnect	(); set( func ); ev.addDelegate( *this );
		}

		void disconnect	() { ListNode::removeFromList(); }

		EV*	 event ()  { return (EV*) ListNode::list();   }

		axStatus onTake( axDelegate & src ) { 
			disconnect(); 
			if( src.event() ) src.event()->addDelegate( *this ); 
			return 0;
		}

		RET	_call (P0 p0, P1 p1, P2 p2) { return functor ? functor->call(p0, p1, p2) : RET(); }

	private:
		axPtr< axIFunctor< RET, P0, P1, P2, void > >	functor;
		char buf[ sizeof( axFunctor< axUnused, RET, P0, P1, P2, void> ) ];
	};

//----- Event 3----------------------------------

	template< class RET, class P0, class P1, class P2 >
	class axEvent< RET, P0, P1, P2, void > : private axTinyList< axDelegate< RET, P0, P1, P2, void > > {
		typedef axDelegate< RET, P0, P1, P2, void > D;
		typedef axTinyList< D > B;
	public:
		void	operator()	(P0 p0, P1 p1, P2 p2)	{ _call(p0, p1, p2); }

		bool	hasDelegate	()			{ return B::head() != NULL; }
		void	addDelegate	( D & d )	{ B::insert(&d); }

		operator	bool()				{ return hasDelegate(); }
		void operator	+=( D & d )		{ addDelegate(d); }

		void	_call (P0 p0, P1 p1, P2 p2) {
			D* p=B::head();
			D* next;
			for( ; p; p=next ) { 
				next = p->next(); // *p might be delete after call
				p->_call(p0, p1, p2);
			} 
		}
	};



//==== 2 Param(s) ======================================

	template< class RET, class P0, class P1 >
	class axIFunctor< RET, P0, P1, void, void > {
	public:
		virtual ~axIFunctor() {}
		virtual	RET call( P0 p0, P1 p1 ) = 0;
	};
	
//---- Functor 2-----------------------------------

	// Member function
	template< class OBJ, class RET, class P0, class P1 >
	class axFunctor< OBJ, RET, P0, P1, void, void > : public axIFunctor< RET, P0, P1, void, void > {
	public:
		typedef RET (OBJ::*Func)( P0 p0, P1 p1 );
		axFunctor( OBJ* obj=nullptr, Func func=nullptr ) : obj_(obj), func_(func) {}
	private:
		OBJ* 	obj_;
		Func	func_;
		virtual RET call( P0 p0, P1 p1 ) { return (obj_->*func_)(p0, p1); }
	};
	
	
	// static function
	template< class RET, class P0, class P1 >
	class axFunctor< void, RET, P0, P1, void, void > : public axIFunctor< RET, P0, P1, void, void > {
	public:
		typedef RET (*Func)( P0 p0, P1 p1 );
		axFunctor( Func func=nullptr ) : func_(func) {}
	private:
		Func	func_;
		virtual RET call( P0 p0, P1 p1 ) { return (*func_)(p0, p1); }
	};

//---- Delegate 2-----------------------------------

	template< class RET, class P0, class P1 >
	class axDelegate< RET, P0, P1, void, void > : public axTinyListNode< axDelegate< RET, P0, P1, void, void >, false > {
	typedef	axEvent		< RET, P0, P1, void, void > EV;
	typedef	axDelegate	< RET, P0, P1, void, void > D;

	typedef	axTinyListNode< D, false > ListNode;
	public:
		RET	operator()	(P0 p0, P1 p1)	{ return _call(p0, p1); }

		axDelegate() {} 

		template< class OBJ >
		axDelegate ( OBJ* obj, RET (OBJ::*method)(P0 p0, P1 p1) ) {
			set(obj,method);
		}

		axDelegate ( RET (*func)(P0 p0, P1 p1) ) {
			set(func);
		}

		template< class OBJ >
		void set ( OBJ* obj, RET (OBJ::*method)(P0 p0, P1 p1) ) {
			functor = new(buf) axFunctor< OBJ, RET, P0, P1, void, void>( obj, method );
		}

		void set ( RET (*func)(P0 p0, P1 p1) ) {
			functor = new(buf) axFunctor< void, RET, P0, P1, void, void>( func );
		}

		template< class OBJ >
		void connect ( EV & ev, OBJ* obj, RET (OBJ::*method)(P0 p0, P1 p1) ) {
			disconnect(); set( obj, method ); ev.addDelegate( *this );
		}

		void connect		( EV & ev, RET (*func)(P0 p0, P1 p1) ) {
			disconnect	(); set( func ); ev.addDelegate( *this );
		}

		void disconnect	() { ListNode::removeFromList(); }

		EV*	 event ()  { return (EV*) ListNode::list();   }

		axStatus onTake( axDelegate & src ) { 
			disconnect(); 
			if( src.event() ) src.event()->addDelegate( *this ); 
			return 0;
		}

		RET	_call (P0 p0, P1 p1) { return functor ? functor->call(p0, p1) : RET(); }

	private:
		axPtr< axIFunctor< RET, P0, P1, void, void > >	functor;
		char buf[ sizeof( axFunctor< axUnused, RET, P0, P1, void, void> ) ];
	};

//----- Event 2----------------------------------

	template< class RET, class P0, class P1 >
	class axEvent< RET, P0, P1, void, void > : private axTinyList< axDelegate< RET, P0, P1, void, void > > {
		typedef axDelegate< RET, P0, P1, void, void > D;
		typedef axTinyList< D > B;
	public:
		void	operator()	(P0 p0, P1 p1)	{ _call(p0, p1); }

		bool	hasDelegate	()			{ return B::head() != NULL; }
		void	addDelegate	( D & d )	{ B::insert(&d); }

		operator	bool()				{ return hasDelegate(); }
		void operator	+=( D & d )		{ addDelegate(d); }

		void	_call (P0 p0, P1 p1) {
			D* p=B::head();
			D* next;
			for( ; p; p=next ) { 
				next = p->next(); // *p might be delete after call
				p->_call(p0, p1);
			} 
		}
	};



//==== 1 Param(s) ======================================

	template< class RET, class P0 >
	class axIFunctor< RET, P0, void, void, void > {
	public:
		virtual ~axIFunctor() {}
		virtual	RET call( P0 p0 ) = 0;
	};
	
//---- Functor 1-----------------------------------

	// Member function
	template< class OBJ, class RET, class P0 >
	class axFunctor< OBJ, RET, P0, void, void, void > : public axIFunctor< RET, P0, void, void, void > {
	public:
		typedef RET (OBJ::*Func)( P0 p0 );
		axFunctor( OBJ* obj=nullptr, Func func=nullptr ) : obj_(obj), func_(func) {}
	private:
		OBJ* 	obj_;
		Func	func_;
		virtual RET call( P0 p0 ) { return (obj_->*func_)(p0); }
	};
	
	
	// static function
	template< class RET, class P0 >
	class axFunctor< void, RET, P0, void, void, void > : public axIFunctor< RET, P0, void, void, void > {
	public:
		typedef RET (*Func)( P0 p0 );
		axFunctor( Func func=nullptr ) : func_(func) {}
	private:
		Func	func_;
		virtual RET call( P0 p0 ) { return (*func_)(p0); }
	};

//---- Delegate 1-----------------------------------

	template< class RET, class P0 >
	class axDelegate< RET, P0, void, void, void > : public axTinyListNode< axDelegate< RET, P0, void, void, void >, false > {
	typedef	axEvent		< RET, P0, void, void, void > EV;
	typedef	axDelegate	< RET, P0, void, void, void > D;

	typedef	axTinyListNode< D, false > ListNode;
	public:
		RET	operator()	(P0 p0)	{ return _call(p0); }

		axDelegate() {} 

		template< class OBJ >
		axDelegate ( OBJ* obj, RET (OBJ::*method)(P0 p0) ) {
			set(obj,method);
		}

		axDelegate ( RET (*func)(P0 p0) ) {
			set(func);
		}

		template< class OBJ >
		void set ( OBJ* obj, RET (OBJ::*method)(P0 p0) ) {
			functor = new(buf) axFunctor< OBJ, RET, P0, void, void, void>( obj, method );
		}

		void set ( RET (*func)(P0 p0) ) {
			functor = new(buf) axFunctor< void, RET, P0, void, void, void>( func );
		}

		template< class OBJ >
		void connect ( EV & ev, OBJ* obj, RET (OBJ::*method)(P0 p0) ) {
			disconnect(); set( obj, method ); ev.addDelegate( *this );
		}

		void connect		( EV & ev, RET (*func)(P0 p0) ) {
			disconnect	(); set( func ); ev.addDelegate( *this );
		}

		void disconnect	() { ListNode::removeFromList(); }

		EV*	 event ()  { return (EV*) ListNode::list();   }

		axStatus onTake( axDelegate & src ) { 
			disconnect(); 
			if( src.event() ) src.event()->addDelegate( *this ); 
			return 0;
		}

		RET	_call (P0 p0) { return functor ? functor->call(p0) : RET(); }

	private:
		axPtr< axIFunctor< RET, P0, void, void, void > >	functor;
		char buf[ sizeof( axFunctor< axUnused, RET, P0, void, void, void> ) ];
	};

//----- Event 1----------------------------------

	template< class RET, class P0 >
	class axEvent< RET, P0, void, void, void > : private axTinyList< axDelegate< RET, P0, void, void, void > > {
		typedef axDelegate< RET, P0, void, void, void > D;
		typedef axTinyList< D > B;
	public:
		void	operator()	(P0 p0)	{ _call(p0); }

		bool	hasDelegate	()			{ return B::head() != NULL; }
		void	addDelegate	( D & d )	{ B::insert(&d); }

		operator	bool()				{ return hasDelegate(); }
		void operator	+=( D & d )		{ addDelegate(d); }

		void	_call (P0 p0) {
			D* p=B::head();
			D* next;
			for( ; p; p=next ) { 
				next = p->next(); // *p might be delete after call
				p->_call(p0);
			} 
		}
	};



//==== 0 Param(s) ======================================

	template< class RET >
	class axIFunctor< RET, void, void, void, void > {
	public:
		virtual ~axIFunctor() {}
		virtual	RET call(  ) = 0;
	};
	
//---- Functor 0-----------------------------------

	// Member function
	template< class OBJ, class RET >
	class axFunctor< OBJ, RET, void, void, void, void > : public axIFunctor< RET, void, void, void, void > {
	public:
		typedef RET (OBJ::*Func)(  );
		axFunctor( OBJ* obj=nullptr, Func func=nullptr ) : obj_(obj), func_(func) {}
	private:
		OBJ* 	obj_;
		Func	func_;
		virtual RET call(  ) { return (obj_->*func_)(); }
	};
	
	
	// static function
	template< class RET >
	class axFunctor< void, RET, void, void, void, void > : public axIFunctor< RET, void, void, void, void > {
	public:
		typedef RET (*Func)(  );
		axFunctor( Func func=nullptr ) : func_(func) {}
	private:
		Func	func_;
		virtual RET call(  ) { return (*func_)(); }
	};

//---- Delegate 0-----------------------------------

	template< class RET >
	class axDelegate< RET, void, void, void, void > : public axTinyListNode< axDelegate< RET, void, void, void, void >, false > {
	typedef	axEvent		< RET, void, void, void, void > EV;
	typedef	axDelegate	< RET, void, void, void, void > D;

	typedef	axTinyListNode< D, false > ListNode;
	public:
		RET	operator()	()	{ return _call(); }

		axDelegate() {} 

		template< class OBJ >
		axDelegate ( OBJ* obj, RET (OBJ::*method)() ) {
			set(obj,method);
		}

		axDelegate ( RET (*func)() ) {
			set(func);
		}

		template< class OBJ >
		void set ( OBJ* obj, RET (OBJ::*method)() ) {
			functor = new(buf) axFunctor< OBJ, RET, void, void, void, void>( obj, method );
		}

		void set ( RET (*func)() ) {
			functor = new(buf) axFunctor< void, RET, void, void, void, void>( func );
		}

		template< class OBJ >
		void connect ( EV & ev, OBJ* obj, RET (OBJ::*method)() ) {
			disconnect(); set( obj, method ); ev.addDelegate( *this );
		}

		void connect		( EV & ev, RET (*func)() ) {
			disconnect	(); set( func ); ev.addDelegate( *this );
		}

		void disconnect	() { ListNode::removeFromList(); }

		EV*	 event ()  { return (EV*) ListNode::list();   }

		axStatus onTake( axDelegate & src ) { 
			disconnect(); 
			if( src.event() ) src.event()->addDelegate( *this ); 
			return 0;
		}

		RET	_call () { return functor ? functor->call() : RET(); }

	private:
		axPtr< axIFunctor< RET, void, void, void, void > >	functor;
		char buf[ sizeof( axFunctor< axUnused, RET, void, void, void, void> ) ];
	};

//----- Event 0----------------------------------

	template< class RET >
	class axEvent< RET, void, void, void, void > : private axTinyList< axDelegate< RET, void, void, void, void > > {
		typedef axDelegate< RET, void, void, void, void > D;
		typedef axTinyList< D > B;
	public:
		void	operator()	()	{ _call(); }

		bool	hasDelegate	()			{ return B::head() != NULL; }
		void	addDelegate	( D & d )	{ B::insert(&d); }

		operator	bool()				{ return hasDelegate(); }
		void operator	+=( D & d )		{ addDelegate(d); }

		void	_call () {
			D* p=B::head();
			D* next;
			for( ; p; p=next ) { 
				next = p->next(); // *p might be delete after call
				p->_call();
			} 
		}
	};





#endif //__axExpandArgList_h__
