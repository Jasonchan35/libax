#ifndef __axEvent_h__
#define __axEvent_h__
#include "../data_structure/axTinyList.h" 

/* !!!! 

This file generated by tools/axEvent_generator.html ( java script ) 

*/



 template< class RET, class P0=void, class P1=void, class P2=void, class P3=void > class axFunctor;
 template< class RET, class P0=void, class P1=void, class P2=void, class P3=void > class axDelegate;
 template< class RET, class P0=void, class P1=void, class P2=void, class P3=void > class axEvent;


//==== 4 Param(s) ======================================

	template< class RET, class P0, class P1, class P2, class P3 >
	class axFunctor {
	public:
	
		template< class OBJ >
		void bind ( OBJ* obj, RET (OBJ::*func)(P0 p0, P1 p1, P2 p2, P3 p3) ) { functor = new(buf) ObjFunctor< OBJ >( obj, func ); }
		void bind (           RET (     *func)(P0 p0, P1 p1, P2 p2, P3 p3) ) { functor = new(buf) StaticFunctor( func ); }
		RET  call ( P0 p0, P1 p1, P2 p2, P3 p3 ) { return functor ? functor->call(p0, p1, p2, p3) : RET(); }
	
	private:
		class IFunctor {
		public:
			virtual	~IFunctor() {}
			virtual	RET call( P0 p0, P1 p1, P2 p2, P3 p3 ) = 0;
		};
	
		template< class OBJ >
		class ObjFunctor : public IFunctor { 
		public:
			typedef RET (OBJ::*Func)( P0 p0, P1 p1, P2 p2, P3 p3 );
			ObjFunctor( OBJ* _obj, Func _func ) : obj(_obj), func(_func) {} 
			OBJ* obj;
			Func func;
			virtual RET call( P0 p0, P1 p1, P2 p2, P3 p3 ) { return ( obj && func ) ? (obj->*func)(p0, p1, p2, p3) : RET(); }
		};
	
		class StaticFunctor : public IFunctor { 
		public:
			typedef RET (*Func)( P0 p0, P1 p1, P2 p2, P3 p3 );
			StaticFunctor( Func _func ) : func(_func) {} 
			Func func;
			virtual RET call( P0 p0, P1 p1, P2 p2, P3 p3 ) { return func ? (*func)(p0, p1, p2, p3) : RET(); }
		};
	
		axPtr< IFunctor > functor;
		char buf[ sizeof( ObjFunctor< axUnused > ) ];
	};
//----- Event 4----------------------------------

	template< class RET, class P0, class P1, class P2, class P3 >
	class axEvent {
	public:

		template< class OBJ >
		axStatus	bind ( OBJ* obj, RET (OBJ::*func)(P0 p0, P1 p1, P2 p2, P3 p3) ) {
			axStatus st;
			axAutoPtr< Delegate >	d(st);	if( !st ) return st; 
			d->bind( obj, func );
			delegates.insert( d.unref() );
			return 0;
		}

		axStatus	bind ( RET (*func)(P0 p0, P1 p1, P2 p2, P3 p3) ) {
			axStatus st;
			axAutoPtr< Delegate >	d(st);	if( !st ) return st; 
			d->bind( func );
			delegates.insert( d.unref() );
			return 0;
		}

		void	operator()	(P0 p0, P1 p1, P2 p2, P3 p3)	{ call(p0, p1, p2, p3); }

		void	call (P0 p0, P1 p1, P2 p2, P3 p3) {
			Delegate*	d = delegates.head();
			Delegate*	next;
			while( d ) {
				d->incRefCount();
				d->functor.call(p0, p1, p2, p3);
				next = d->next();
				d->decRefCount();
				d = next;
			}
		}

		class Delegate : public axTinyListNode< Delegate, true > {
			typedef	axFunctor	< RET, P0, P1, P2, P3 > Functor;
		public:
			Delegate() { refCount_=1; }
			template< class OBJ >
			void bind ( OBJ* obj, RET (OBJ::*func)(P0 p0, P1 p1, P2 p2, P3 p3) ) { functor.bind(obj,func); objRef.ref(obj); }
			void bind (           RET (     *func)(P0 p0, P1 p1, P2 p2, P3 p3) ) { functor.bind(func); }
			RET call( P0 p0, P1 p1, P2 p2, P3 p3 ) { return functor.call(); }

			class ObjRef : public axRef< axReferred > {
			public:
				virtual void	onWillRemoveFromList() { owner().decRefCount(); }
				Delegate & owner() { return ax_member_owner( & Delegate::objRef, this ); } 
			};

			void incRefCount() { refCount_++; } 
			void decRefCount() { refCount_--; if( refCount_ <= 0 ) delete this; } 
			ObjRef  objRef;
			int refCount_;
			Functor functor;
		};

		axTinyList< Delegate >	delegates;
	};



//==== 3 Param(s) ======================================

	template< class RET, class P0, class P1, class P2 >
	class axFunctor< RET, P0, P1, P2, void > {
	public:
	
		template< class OBJ >
		void bind ( OBJ* obj, RET (OBJ::*func)(P0 p0, P1 p1, P2 p2) ) { functor = new(buf) ObjFunctor< OBJ >( obj, func ); }
		void bind (           RET (     *func)(P0 p0, P1 p1, P2 p2) ) { functor = new(buf) StaticFunctor( func ); }
		RET  call ( P0 p0, P1 p1, P2 p2 ) { return functor ? functor->call(p0, p1, p2) : RET(); }
	
	private:
		class IFunctor {
		public:
			virtual	~IFunctor() {}
			virtual	RET call( P0 p0, P1 p1, P2 p2 ) = 0;
		};
	
		template< class OBJ >
		class ObjFunctor : public IFunctor { 
		public:
			typedef RET (OBJ::*Func)( P0 p0, P1 p1, P2 p2 );
			ObjFunctor( OBJ* _obj, Func _func ) : obj(_obj), func(_func) {} 
			OBJ* obj;
			Func func;
			virtual RET call( P0 p0, P1 p1, P2 p2 ) { return ( obj && func ) ? (obj->*func)(p0, p1, p2) : RET(); }
		};
	
		class StaticFunctor : public IFunctor { 
		public:
			typedef RET (*Func)( P0 p0, P1 p1, P2 p2 );
			StaticFunctor( Func _func ) : func(_func) {} 
			Func func;
			virtual RET call( P0 p0, P1 p1, P2 p2 ) { return func ? (*func)(p0, p1, p2) : RET(); }
		};
	
		axPtr< IFunctor > functor;
		char buf[ sizeof( ObjFunctor< axUnused > ) ];
	};
//----- Event 3----------------------------------

	template< class RET, class P0, class P1, class P2 >
	class axEvent< RET, P0, P1, P2, void > {
	public:

		template< class OBJ >
		axStatus	bind ( OBJ* obj, RET (OBJ::*func)(P0 p0, P1 p1, P2 p2) ) {
			axStatus st;
			axAutoPtr< Delegate >	d(st);	if( !st ) return st; 
			d->bind( obj, func );
			delegates.insert( d.unref() );
			return 0;
		}

		axStatus	bind ( RET (*func)(P0 p0, P1 p1, P2 p2) ) {
			axStatus st;
			axAutoPtr< Delegate >	d(st);	if( !st ) return st; 
			d->bind( func );
			delegates.insert( d.unref() );
			return 0;
		}

		void	operator()	(P0 p0, P1 p1, P2 p2)	{ call(p0, p1, p2); }

		void	call (P0 p0, P1 p1, P2 p2) {
			Delegate*	d = delegates.head();
			Delegate*	next;
			while( d ) {
				d->incRefCount();
				d->functor.call(p0, p1, p2);
				next = d->next();
				d->decRefCount();
				d = next;
			}
		}

		class Delegate : public axTinyListNode< Delegate, true > {
			typedef	axFunctor	< RET, P0, P1, P2, void > Functor;
		public:
			Delegate() { refCount_=1; }
			template< class OBJ >
			void bind ( OBJ* obj, RET (OBJ::*func)(P0 p0, P1 p1, P2 p2) ) { functor.bind(obj,func); objRef.ref(obj); }
			void bind (           RET (     *func)(P0 p0, P1 p1, P2 p2) ) { functor.bind(func); }
			RET call( P0 p0, P1 p1, P2 p2 ) { return functor.call(); }

			class ObjRef : public axRef< axReferred > {
			public:
				virtual void	onWillRemoveFromList() { owner().decRefCount(); }
				Delegate & owner() { return ax_member_owner( & Delegate::objRef, this ); } 
			};

			void incRefCount() { refCount_++; } 
			void decRefCount() { refCount_--; if( refCount_ <= 0 ) delete this; } 
			ObjRef  objRef;
			int refCount_;
			Functor functor;
		};

		axTinyList< Delegate >	delegates;
	};



//==== 2 Param(s) ======================================

	template< class RET, class P0, class P1 >
	class axFunctor< RET, P0, P1, void, void > {
	public:
	
		template< class OBJ >
		void bind ( OBJ* obj, RET (OBJ::*func)(P0 p0, P1 p1) ) { functor = new(buf) ObjFunctor< OBJ >( obj, func ); }
		void bind (           RET (     *func)(P0 p0, P1 p1) ) { functor = new(buf) StaticFunctor( func ); }
		RET  call ( P0 p0, P1 p1 ) { return functor ? functor->call(p0, p1) : RET(); }
	
	private:
		class IFunctor {
		public:
			virtual	~IFunctor() {}
			virtual	RET call( P0 p0, P1 p1 ) = 0;
		};
	
		template< class OBJ >
		class ObjFunctor : public IFunctor { 
		public:
			typedef RET (OBJ::*Func)( P0 p0, P1 p1 );
			ObjFunctor( OBJ* _obj, Func _func ) : obj(_obj), func(_func) {} 
			OBJ* obj;
			Func func;
			virtual RET call( P0 p0, P1 p1 ) { return ( obj && func ) ? (obj->*func)(p0, p1) : RET(); }
		};
	
		class StaticFunctor : public IFunctor { 
		public:
			typedef RET (*Func)( P0 p0, P1 p1 );
			StaticFunctor( Func _func ) : func(_func) {} 
			Func func;
			virtual RET call( P0 p0, P1 p1 ) { return func ? (*func)(p0, p1) : RET(); }
		};
	
		axPtr< IFunctor > functor;
		char buf[ sizeof( ObjFunctor< axUnused > ) ];
	};
//----- Event 2----------------------------------

	template< class RET, class P0, class P1 >
	class axEvent< RET, P0, P1, void, void > {
	public:

		template< class OBJ >
		axStatus	bind ( OBJ* obj, RET (OBJ::*func)(P0 p0, P1 p1) ) {
			axStatus st;
			axAutoPtr< Delegate >	d(st);	if( !st ) return st; 
			d->bind( obj, func );
			delegates.insert( d.unref() );
			return 0;
		}

		axStatus	bind ( RET (*func)(P0 p0, P1 p1) ) {
			axStatus st;
			axAutoPtr< Delegate >	d(st);	if( !st ) return st; 
			d->bind( func );
			delegates.insert( d.unref() );
			return 0;
		}

		void	operator()	(P0 p0, P1 p1)	{ call(p0, p1); }

		void	call (P0 p0, P1 p1) {
			Delegate*	d = delegates.head();
			Delegate*	next;
			while( d ) {
				d->incRefCount();
				d->functor.call(p0, p1);
				next = d->next();
				d->decRefCount();
				d = next;
			}
		}

		class Delegate : public axTinyListNode< Delegate, true > {
			typedef	axFunctor	< RET, P0, P1, void, void > Functor;
		public:
			Delegate() { refCount_=1; }
			template< class OBJ >
			void bind ( OBJ* obj, RET (OBJ::*func)(P0 p0, P1 p1) ) { functor.bind(obj,func); objRef.ref(obj); }
			void bind (           RET (     *func)(P0 p0, P1 p1) ) { functor.bind(func); }
			RET call( P0 p0, P1 p1 ) { return functor.call(); }

			class ObjRef : public axRef< axReferred > {
			public:
				virtual void	onWillRemoveFromList() { owner().decRefCount(); }
				Delegate & owner() { return ax_member_owner( & Delegate::objRef, this ); } 
			};

			void incRefCount() { refCount_++; } 
			void decRefCount() { refCount_--; if( refCount_ <= 0 ) delete this; } 
			ObjRef  objRef;
			int refCount_;
			Functor functor;
		};

		axTinyList< Delegate >	delegates;
	};



//==== 1 Param(s) ======================================

	template< class RET, class P0 >
	class axFunctor< RET, P0, void, void, void > {
	public:
	
		template< class OBJ >
		void bind ( OBJ* obj, RET (OBJ::*func)(P0 p0) ) { functor = new(buf) ObjFunctor< OBJ >( obj, func ); }
		void bind (           RET (     *func)(P0 p0) ) { functor = new(buf) StaticFunctor( func ); }
		RET  call ( P0 p0 ) { return functor ? functor->call(p0) : RET(); }
	
	private:
		class IFunctor {
		public:
			virtual	~IFunctor() {}
			virtual	RET call( P0 p0 ) = 0;
		};
	
		template< class OBJ >
		class ObjFunctor : public IFunctor { 
		public:
			typedef RET (OBJ::*Func)( P0 p0 );
			ObjFunctor( OBJ* _obj, Func _func ) : obj(_obj), func(_func) {} 
			OBJ* obj;
			Func func;
			virtual RET call( P0 p0 ) { return ( obj && func ) ? (obj->*func)(p0) : RET(); }
		};
	
		class StaticFunctor : public IFunctor { 
		public:
			typedef RET (*Func)( P0 p0 );
			StaticFunctor( Func _func ) : func(_func) {} 
			Func func;
			virtual RET call( P0 p0 ) { return func ? (*func)(p0) : RET(); }
		};
	
		axPtr< IFunctor > functor;
		char buf[ sizeof( ObjFunctor< axUnused > ) ];
	};
//----- Event 1----------------------------------

	template< class RET, class P0 >
	class axEvent< RET, P0, void, void, void > {
	public:

		template< class OBJ >
		axStatus	bind ( OBJ* obj, RET (OBJ::*func)(P0 p0) ) {
			axStatus st;
			axAutoPtr< Delegate >	d(st);	if( !st ) return st; 
			d->bind( obj, func );
			delegates.insert( d.unref() );
			return 0;
		}

		axStatus	bind ( RET (*func)(P0 p0) ) {
			axStatus st;
			axAutoPtr< Delegate >	d(st);	if( !st ) return st; 
			d->bind( func );
			delegates.insert( d.unref() );
			return 0;
		}

		void	operator()	(P0 p0)	{ call(p0); }

		void	call (P0 p0) {
			Delegate*	d = delegates.head();
			Delegate*	next;
			while( d ) {
				d->incRefCount();
				d->functor.call(p0);
				next = d->next();
				d->decRefCount();
				d = next;
			}
		}

		class Delegate : public axTinyListNode< Delegate, true > {
			typedef	axFunctor	< RET, P0, void, void, void > Functor;
		public:
			Delegate() { refCount_=1; }
			template< class OBJ >
			void bind ( OBJ* obj, RET (OBJ::*func)(P0 p0) ) { functor.bind(obj,func); objRef.ref(obj); }
			void bind (           RET (     *func)(P0 p0) ) { functor.bind(func); }
			RET call( P0 p0 ) { return functor.call(); }

			class ObjRef : public axRef< axReferred > {
			public:
				virtual void	onWillRemoveFromList() { owner().decRefCount(); }
				Delegate & owner() { return ax_member_owner( & Delegate::objRef, this ); } 
			};

			void incRefCount() { refCount_++; } 
			void decRefCount() { refCount_--; if( refCount_ <= 0 ) delete this; } 
			ObjRef  objRef;
			int refCount_;
			Functor functor;
		};

		axTinyList< Delegate >	delegates;
	};



//==== 0 Param(s) ======================================

	template< class RET >
	class axFunctor< RET, void, void, void, void > {
	public:
	
		template< class OBJ >
		void bind ( OBJ* obj, RET (OBJ::*func)() ) { functor = new(buf) ObjFunctor< OBJ >( obj, func ); }
		void bind (           RET (     *func)() ) { functor = new(buf) StaticFunctor( func ); }
		RET  call (  ) { return functor ? functor->call() : RET(); }
	
	private:
		class IFunctor {
		public:
			virtual	~IFunctor() {}
			virtual	RET call(  ) = 0;
		};
	
		template< class OBJ >
		class ObjFunctor : public IFunctor { 
		public:
			typedef RET (OBJ::*Func)(  );
			ObjFunctor( OBJ* _obj, Func _func ) : obj(_obj), func(_func) {} 
			OBJ* obj;
			Func func;
			virtual RET call(  ) { return ( obj && func ) ? (obj->*func)() : RET(); }
		};
	
		class StaticFunctor : public IFunctor { 
		public:
			typedef RET (*Func)(  );
			StaticFunctor( Func _func ) : func(_func) {} 
			Func func;
			virtual RET call(  ) { return func ? (*func)() : RET(); }
		};
	
		axPtr< IFunctor > functor;
		char buf[ sizeof( ObjFunctor< axUnused > ) ];
	};
//----- Event 0----------------------------------

	template< class RET >
	class axEvent< RET, void, void, void, void > {
	public:

		template< class OBJ >
		axStatus	bind ( OBJ* obj, RET (OBJ::*func)() ) {
			axStatus st;
			axAutoPtr< Delegate >	d(st);	if( !st ) return st; 
			d->bind( obj, func );
			delegates.insert( d.unref() );
			return 0;
		}

		axStatus	bind ( RET (*func)() ) {
			axStatus st;
			axAutoPtr< Delegate >	d(st);	if( !st ) return st; 
			d->bind( func );
			delegates.insert( d.unref() );
			return 0;
		}

		void	operator()	()	{ call(); }

		void	call () {
			Delegate*	d = delegates.head();
			Delegate*	next;
			while( d ) {
				d->incRefCount();
				d->functor.call();
				next = d->next();
				d->decRefCount();
				d = next;
			}
		}

		class Delegate : public axTinyListNode< Delegate, true > {
			typedef	axFunctor	< RET, void, void, void, void > Functor;
		public:
			Delegate() { refCount_=1; }
			template< class OBJ >
			void bind ( OBJ* obj, RET (OBJ::*func)() ) { functor.bind(obj,func); objRef.ref(obj); }
			void bind (           RET (     *func)() ) { functor.bind(func); }
			RET call(  ) { return functor.call(); }

			class ObjRef : public axRef< axReferred > {
			public:
				virtual void	onWillRemoveFromList() { owner().decRefCount(); }
				Delegate & owner() { return ax_member_owner( & Delegate::objRef, this ); } 
			};

			void incRefCount() { refCount_++; } 
			void decRefCount() { refCount_--; if( refCount_ <= 0 ) delete this; } 
			ObjRef  objRef;
			int refCount_;
			Functor functor;
		};

		axTinyList< Delegate >	delegates;
	};





#endif //__axExpandArgList_h__
